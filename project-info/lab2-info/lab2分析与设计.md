# lab 2分析与设计

lab 2共有三个任务：在原五级流水线的基础上增加实现的指令；实现握手总线；实现不同粒度的内存读写；

## 一、增加实现的指令与功能

### 1、bne（B-type）

![](img/bne.png)

若`rs1`与`rs2`的数据不相等，进行跳转；跳转的目标pc为pc + immediate；立即数的[12 : 1]被打散存在指令中，扩展后的立即数为：

```verilog
immediate = {
    {51{instruction[31]}},	// immediate [63 : 13]	
    instruction[31],		// immediate [12]
    instruction[7],			// immediate [11]
    instruction[30 : 25],	// immediate [10 : 5]
    instruction[11 : 8], 	// immediate [4 : 1]
    0 						// immediate [0]
};
```

alu操作数为两个寄存器数据，操作为`not_equal`；

### 2、blt（B-type）

![](img/blt.png)

若`rs1`号寄存器的数据 < `rs2`号寄存器的数据，进行跳转（此处>=运算为把寄存器数据视为**二进制补码，即有符号数**后得到的计算结果）；跳转目标pc为pc + immediate；立即数的[12 : 1]被打散存在指令中，扩展后的立即数与`bne`指令一致；

alu操作数为两个寄存器数据，操作为`less`；

### 3、bge（B-type）

![](img/bge.png)

若`rs1`号寄存器的数据 >= `rs2`号寄存器的数据，进行跳转（此处>=运算为把寄存器数据视为**二进制补码，即有符号数**后得到的计算结果）；跳转目标pc为pc + immediate；立即数的[12 : 1]被打散存在指令中，扩展后的立即数与`bne`指令一致；

alu操作数为两个寄存器数据，操作为`greater`；

### 4、bltu（B-type）

![](img/bltu.png)

若`rs1`号寄存器的数据 < `rs2`号寄存器的数据，进行跳转（此处<运算为把寄存器数据视为**无符号数**后得到的计算结果）；跳转目标pc为pc + immediate；立即数的[12 : 1]被打散存在指令中，扩展后的立即数与`bne`指令一致；

alu操作数为两个寄存器数据，操作为`less_u`；

### 5、bgeu（B-type）

![](img/bgeu.png)

若`rs1`号寄存器的数据 >= `rs2`号寄存器的数据，进行跳转（此处<运算为把寄存器数据视为**无符号数**后得到的计算结果）；跳转目标pc为pc + immediate；立即数的[12 : 1]被打散存在指令中，扩展后的立即数与`bne`指令一致；

alu操作数为两个寄存器数据，操作为`greater_u`；

### 6、slti（I-type）

![](img/slti.png)

比较`rs1`寄存器数据与扩展后的立即数，把比较的结果写入`rd`寄存器（0或1）：若`[rs1]` < `immediate`为1，反之为0。（此处比较为**二进制补码即有符号数**的比较）

alu操作数1为寄存器数据，操作数2为扩展后的立即数，立即数扩展为正常符号扩展（到64位）；alu操作为`less`；

###  7、sltiu（I-type）

![](img/sltiu.png)

比较`rs1`寄存器数据与扩展后的立即数，把比较的结果写入`rd`寄存器（0或1）：若`[rs1]` < `immediate`为1，反之为0。（此处比较为**无符号数**的比较）

alu操作数1为寄存器数据，操作数2为扩展后的立即数，立即数扩展为正常符号扩展（到64位）；alu操作为`less_u`；

### 8、slli（I-type）

![](img/slli.png)

把`rs1`的数据左移`shamt`位，低位补0，结果写入`rd`；（因为实现位`RV64I`，所以`shamt`始终有效）；`shamt`为6位，无符号扩展到64：

```verilog
immediate = { 
    58'b0, 
    shamt			//instruction[25 : 20]
};
```

alu操作数1为寄存器数据，操作数2为扩展后的`shamt`，alu操作为`shiftl`；

### 9、srli（I-type）

![](img/srli.png)

把`rs1`的数据右移`shamt`位，高位补0，结果写入`rd`；`shamt`为6位，无符号扩展到64位；

alu操作数1为寄存器数据，操作数2为扩展后的`shamt`，alu操作为`shiftr`；

### 10、srai（I-type）

![](img/srai.png)

把`rs1`的数据**算数右移**，空位用`rs1`的最高位补充，结果写入`rd`；`shamt`为6位，无符号扩展到64；

alu操作数1为寄存器数据，操作数2为扩展后的`shamt`；alu操作为`shiftr_s`；

### 11、addiw（I-type）

![](img/addiw.png)

将`rs1`与扩展后的立即数相加，结果截断为32位，低32位取计算结果，高32位符号扩展；

alu操作数1为寄存器数据，操作数2为扩展后的立即数；alu操作为`add`；

计算出结果后需要进行32位截断（decode阶段产生截断信号）；

### 12、slliw（I-type）

![](img/slliw.png)

将`rs1`进行逻辑左移`shamt`位（需要无符号扩展），结果截断为32位，低32位取计算结果，高32位符号扩展；

alu操作数1为寄存器数据，操作数2为扩展后的立即数；alu操作为`shiftl`；

计算出结果后需要进行32位截断（decode阶段产生截断信号）；`shamt[5] = 0`时才进行操作。

### 13、srliw（I-type）

![](img/srliw.png)

将`rs1`进行逻辑右移`shamt`位（需要无符号扩展），结果截断为32位，低32位取计算结果，高32位符号扩展；

alu操作数1为寄存器数据，操作数2为扩展后的立即数；alu操作为`shiftr`；

### 14、sraiw（I-type）

![](img/sraiw.png)

取`rs1`的低32位，进行算数右移`shamt`位，空位符号扩展；

alu操作数1为寄存器数据，操作数2为扩展后的立即数；alu操作为`shiftr_s`；

计算出结果后需要进行32位截断（decode阶段产生截断信号）；`shamt[5] = 0`时才进行操作。

### 15、sll（R-type）

![](img/sll.png)

把`rs1`寄存器数据左移`rs2`位（逻辑左移），结果写入`rd`寄存器；`rs2`的数据经过处理得到`srcb`：

```verilog
srcb = {
    58'b0,			// 高位补0
    rd2[5 : 0]		// rd2的低六位作为移位数据
}
```

alu操作数1为寄存器数据`[rs1]`，操作数2为经过处理的寄存器数据`[rs2]`；alu操作为`shiftl`；

### 16、slt（R-type）

![](img/slt.png)

比较`rs1`号寄存器与`rs2`号寄存器的数据大小，若`rs1`小结果为1，反之为0；把结果写入`rd`；

alu操作数为两个寄存器数据，alu操作为`less`；

### 17、sltu（R-type）

![](img/sltu.png)

比较`rs1`号寄存器与`rs2`号寄存器的数据大小，若`rs1`小结果为1，反之为0；把结果写入`rd`；（小于为无符号比较小于）

alu操作数为两个寄存器数据，alu操作为`less_u`；

### 18、srl（R-type）

![](img/srl.png)

把`rs1`寄存器数据右移`rs2`位（逻辑右移），结果写入`rd`寄存器；`rs2`的数据经过处理得到`srcb`，处理同`sll`

alu操作数1为寄存器数据`[rs1]`，操作数2为经过处理的寄存器数据`[rs2]`；alu操作为`shiftr`；

### 19、sra（R-type）

![](img/sra.png)

把`rs1`寄存器数据右移`rs2`位（算术右移），结果写入`rd`寄存器；`rs2`的数据经过处理得到`srcb`，处理同`sll`；

alu操作数1为寄存器数据`[rs1]`，操作数2为经过处理的寄存器数据`[rs2]`；alu操作为`shiftr_s`；

### 20、addw（R-type）

![](img/addw.png)

将`rs1`与`rs2`相加，结果截断为32位，低32位取计算结果，高32位符号扩展；

alu操作数1为寄存器数据，操作数2为扩展后的立即数；alu操作为`add`；

计算出结果后需要进行32位截断（decode阶段产生截断信号）；

### 21、subw（R-type）

![](img/subw.png)

将`rs1`与`rs2`相减，结果截断为32位，低32位取计算结果，高32位符号扩展；

alu操作数1为寄存器数据，操作数2为扩展后的立即数；alu操作为`sub`；

计算出结果后需要进行32位截断（decode阶段产生截断信号）；

### 22、sllw（R-type）

![](img/sllw.png)

取`rs1`逻辑左移`rs2`位，`rs2`寄存器数据处理后得到一个5位数据，为移位的位数：

```verilog
shamt = {
    59'b0,			// 高位补0
    rs2[4 : 0]		// 低5位
}
```

结果取低32位，高32位符号扩展；

alu操作数1为寄存器数据，操作数2为扩展后的立即数；alu操作为`shiftl`；移位后需要进行立即数扩展

### 23、srlw（R-type）

![](img/srlw.png)

取`rs1`逻辑右移`rs2`位，`rs2`寄存器数据处理后得到一个5位数据，为移位的位数，处理同`sllw`

结果取低32位，高32位符号扩展；

alu操作数1为寄存器数据，操作数2为扩展后的立即数；alu操作为`shiftr`；移位后需要进行立即数扩展

### 24、sraw（R-type）

![](img/sraw.png)

取`rs1`算术右移`rs2`位，`rs2`寄存器数据处理后得到一个5位数据，为移位的位数，处理同`sllw`

结果取低32位，高32位符号扩展；

alu操作数1为寄存器数据，操作数2为扩展后的立即数；alu操作为`shiftr_s`；移位后需要进行立即数扩展；

## 二、实现增加指令添加的逻辑

### 1、alu的操作类型

alu的操作在原有的基础上添加以下操作：

`not_equal`：判断`srca`和`srcb`是否不相等；

`less`：若`srca` < `srcb`，结果为1，反之为0；（按补码比较）

`greater`：若`srca` > `srcb`，结果为1，反之为0；（按补码比较）

`less_u`：若`srca` < `srcb`，结果为1，反之为0；（按无符号整数比较）

`greater_u`：若`srca` > `srcb`，结果为1，反之为0；（按无符号整数比较）

`shiftl`：把`srca`逻辑左移`srcb`位；

`shiftr`：把`srca`逻辑右移`srcb`位；

`shiftr_s`：把`srca`算数右移`srcb`位；

### 2、立即数的扩展类型

在原有的基础上，增加一种`decode`阶段的立即数扩展情况：

即移位的情况下，将`shamt`从6位无符号扩展为64位，便于在execute阶段直接计算；处理如下：

```verilog
immediate = { 
    58'b0, 
    shamt			//instruction[25 : 20]
};
```

### 3、操作数的处理类型

同样是处理移位的逻辑，当进行R-type的移位操作，需要将操作数2处理为相应的移位数，两种情况：

（1）64位操作

```verilog
srcb = {
    58'b0,			// 高位补0
    rd2[5 : 0]		// rd2的低六位作为移位数据
}
```

（2）32位操作

```verilog
srcb = {
    58'b0,			// 高位补0
    rd2[4 : 0]		// rd2的低五位作为移位数据
}
```

### 3、alu的操作过程

由于存在32位运算的几条指令：`addiw`、`slliw`……

这些指令需要在32位的背景下进行运算，然后扩展为64位的数据。在此基础上将alu修改为三个过程：

（1）计算前的截取数据（两个操作数都要截断）：根据信号判断是否需要对数据进行截断处理；

（2）将处理后的数据交由运算单元计算；

（3）计算后对数据进行位扩展：根据信号判断是否需要截断32位高位符号扩展；

因为在32位运算的情况下，截断和位扩展的操作其实是运算的一部分，因此一并放在alu中进行，减少execute流水段复杂的处理逻辑。

## 三、握手总线

握手总线主要用来处理访存（包括指令访存和数据访存）的问题，在访存的时候，由于访存周期的不确定性，不能简单地按周期进行流水，需要引入握手总线协议从而处理访存。

**把每次访存看作一次请求和响应的过程，请求标志着一次访存任务的开始，即访存地址和访存使能就位，响应标志着一次访存任务的结束，即访存得到的数据就位。**请求和响应模块的端口分别如下，以data为例：

**访存请求端口**：

```verilog
typedef struct packed {
    logic valid; // in request?
    addr_t addr; // target address
    // ...
} dbus_req_t;
```

在请求端口中，`valid`信号表示访存任务是否开始（即是否进行访存请求），后续流水线的状态会根据访存的情况进行调整；`addr`信号表示访存地址。

**访存响应端口**：

```verilog
typedef struct packed {
    logic addr_ok;	// 此次lab（总线上）的总线协议中用不到
    logic data_ok; // is the field "data" valid? 
    word_t data; // the data read from cache
} dbus_resp_t;
```

`data_ok`信号表示访存请求的响应已就位（在此次的总线协议下），此时的`data`信号就是从memory中读取到的指令或数据。当`data_ok`信号为有效低电平时（有效是指`req.valid`信号为1，即访存请求发出），说明访存还未结束，此时`data`信号就是无效数据。

综上：请求端口的`valid`信号标志着访存请求的发出（即开始访存指令）；响应端口的`data_ok`信号标志着访存请求的结束（即读到正确的内存数据）。

总线协议如下：

> - `req.valid`为0时， `resp.data_ok` 为不定值。
> - `req.valid`为1期间，代表一次访存请求。在此期间， `req.valid` 与 `req.addr` 不允许改变。
> - `req.valid` 为1时，检查`resp.data_ok` 。如果为1，则下个时钟的上升沿表示一次握手，本次访存结束。如果握手后 `req.valid` 仍为1，则视为新的一次请求。

## 四、流水线改动

握手总线主要改动在于涉及访存的流水段：`fetch`与`memory`；考虑如何通过信号和连线引入握手总线。

### 1、fetch流水段

当前fetch阶段取指的代码如下：

```verilog
```

